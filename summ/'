# -*- coding: utf-8 -*-


from typing import List
from logging import Logger

from summ.kv_stores.kv_store import KVStore
from summ.entity import Entity


class MetricCalc:
    def __init__(self, logger: Logger, kvstore: KVStore):
        self._logger = logger
        self._kvstore = kvstore
        self._device_id_metrics = {'min', 'max', 'mean',}
        self._event_type_metrics = {'hist10',}
    
    def calc_stats(
            self, 
            device_id: str = '*',
            event_type: str = '*',
            metrics: List[str] = ['*']
        ) -> dict:
        """ Calculate the metrics for given device_id or event_type.
        If both of them are provided, an empty dict will be return ed.
            
        Args:
            device_id: the name of device_id.
            event_type: the name of event_type.
            metrics: list of metric names, for example ['min', 'max']
            
        Returns:
            A dict object stores the calculated metrics.
        """
        res = {}
        
        eval_type = 'device_id_stats'  # Assume evaluating device_id by default

        


        if not key:
            return res

        if key != '*' and !Entity.is_device_id(key):
            return res
            
        # Check the name of given metrics
        filtered_metrics = []
        if len(metrics) == 1 and metrics[0] == '*':
            filtered_metrics = list(self._device_id_metrics)
        else:
            for m in metrics:
                if m in self._device_id_metrics:
                    filtered_metrics.append(m)

        if not filtered_metrics:
            return res
        
        # Do calculation Iteratively
        for k in self._kvstore.keys():
            dev_id, ev_type = Entity.disjoin_key(k)
            if not dev_id or not ev_type:
                continue
            
            # Not a match device_id.
            if key != * and dev_id != key:
                continue

            self._update_stats_once(dev_id, int(self._kvstore.get(dev_id)), filtered_metrics, res)

        return res
            
    def _update_stats_once(self, key: str, val: int,  metrics: List[str], metric_buf: dict) -> None:
        if key in metric_buf:
            stat = metric_buf[key]
        else:
            stat = {'cnt': 0}
            metric_buf[key] = stat

        # Count in current key. Please aware while calculating complex statistics.
        stat['cnt'] += 1

        for metric in metrics:
            if metric == 'min':
                if 'min' not in stat:
                    stat['min'] = val
                elif val < stat['min']:
                    stat['min'] = val

            if metric == 'max':
                if 'max' not in stat:
                    stat['max'] = val
                elif val > stat['max']:
                    stat['max'] = val

            if metric == 'mean':
                if 'mean' not in stat:
                    stat['mean'] = val
                else:
                    stat['mean'] += (val - stat['mean'])/stat['cnt']

        metric[key] = stat
        
